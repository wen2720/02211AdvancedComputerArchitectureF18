#!/bin/bash
#
# functions to detect ruby, gem and rdoc
#

RUBY_MIN_VER=(1 9 0)

function ruby_chk_ver {
  local i=$1
  local x=${2-0}
  shift 2
  local rest=$@

  if [[ $x > ${RUBY_MIN_VER[$i]} ]]; then
    true
  elif [[ $x == ${RUBY_MIN_VER[$i]} ]]; then
    ruby_chk_ver $(( $i + 1 )) $rest
  else
    false
  fi
}

function detect_ruby {
    local fail
    RUBY=$(which ruby)
    if [[ $? != 0 ]]
    then
	echo "ruby not found. Please install ruby (e.g., sudo aptitude install ruby)" >&2
	exit 1
    fi

    RUBY_VERSION_STRING=$(ruby -e 'puts RUBY_VERSION')
    RUBY_VER=(${RUBY_VERSION_STRING//./ })

    if ! ruby_chk_ver 0 ${RUBY_VER[@]}
    then
        local ruby_min_ver_str=${RUBY_MIN_VER[*]}
	echo "Cannot detect ruby >= ${ruby_min_ver_str// /.}. Falling back to unsupported ruby version $(${RUBY} -v)" >&2
    fi
}

function detect_gem_command {
    GEMs="gem"
    for g in ${GEMs} ; do
        if [ ! -z "`which ${g}  2>/dev/null`" ] ; then
            GEM="$g"
            break
        fi
    done
    if [ -z "${GEM}" ] ; then
        echo "gem not found. Please make sure there is a 'gem' command for managing ruby libraries" >&2
    fi
}
detect_ruby
detect_gem_command

if [ -z "${GEM}" ] ; then
  export GEM_PATH="/home/patmos/t-crest_original/misc/local/lib/platin/gems"
else
  CURRENT_GEM_PATH=$(${GEM} env gempath)
  export GEM_PATH="/home/patmos/t-crest_original/misc/local/lib/platin/gems:${CURRENT_GEM_PATH}"
fi

RELATIVE_LIBDIR="../lib/platin"
#!/bin/bash
#
# ruby-runner

# the installer will inject code to detect the ruby executable before
if [ -z "${RUBY}" ] ; then
    RUBY=ruby
fi

# Set library path for installation

KNOWN_COMMANDS="wcet tool-config pml analyze-trace extract-symbols pml-config\
      transform visualize inspect ait2pml pml2ais pml2ffx sweet ff2pml wca late-bypass"
usage() {
    cat <<EOF >&2
usage: platin <command> [<args>]

The following platin tools are available and supported:

  wcet            ... Calculate WCET (main driver)
  tool-config     ... Configure tools, so the same HW config is used in
                      compiler, WCA and simulator
  pml-config      ... Create or modify PML machine configurations.
  pml             ... Validate/Inspect/Visualize/Merge PML files
  analyze-trace   ... Analyze simulator trace and generate flow facts
  extract-symbols ... Extract addresses of symbols from ELF file
  sweet           ... Run SWEET analysis tool
  transform       ... Transform flowfacts from bitcode to machinecode
                      (and vice versa)
  visualize       ... Visualize IR and MC CFGs as well as relation graphs
                      [alpha]
  inspect         ... Inspect the program structure and flow facts/loop bounds
  pml2ais         ... Translate program information to aiT's AIS format
  pml2ffx         ... Translate program information to oRange/OTAWA's F4/FFX format

The following tools are available for internal use only:

  ait2pml         ... Add aiT analysis results to the PML database
  ff2pml          ... Translate SWEET flowfacts to PML
  wca             ... Calculate WCET cost using lp_solve
  late-bypass     ... Rewrite memory instructions in the binary to bypass
                      the data cache

EOF
    UNKNOWN=`echo $(list_unknown_commands)`
    if [ ! -z "${UNKNOWN}" ]; then
	echo "Undocumented commands: ${UNKNOWN}" >&2
	echo >&2
    fi
    echo "See 'platin help <command>' for more information on a specific command." >&2
}

show_help() {
    COMMAND=$1
    shift
    ${RUBY} -I ${LIBDIR} ${LIBDIR}/tools/"${COMMAND}".rb --help
}

list_unknown_commands() {
    for driver in $(ls "${LIBDIR}"/tools/*.rb) ; do
	name=$(basename "${driver}" .rb)
	unset known
	for cmd in ${KNOWN_COMMANDS} ; do
	    if [ $name == $cmd ] ; then known=yes ; break ; fi
	done
	if [ -z "${known}" ]; then echo ${name} ; fi
    done
}

# Set LIBDIR fallback
if [ -z "${RELATIVE_LIBDIR}" ] ; then
    RELATIVE_LIBDIR=lib
fi
if [ -z "${LIBDIR}" ] ; then
    LIBDIR=$(dirname $0)/"${RELATIVE_LIBDIR}"
fi

# Select command
COMMAND=$1
shift
if [ -z "${COMMAND}" ] ; then
    usage
    exit 1
elif [ "${COMMAND}" == "help" -o "${COMMAND}" == "--help" ] ; then
    if [ -z "${1}" ] ; then
	usage
    else
	show_help $1
    fi
    exit 0
fi

# Define command script
COMMAND_SCRIPT="${LIBDIR}"/tools/"${COMMAND}".rb
if [ ! -e "${COMMAND_SCRIPT}" ] ; then
    echo "Unknown command '${COMMAND}' (could not find implementation)" >&2
    usage
    exit 1
fi

# Run command
exec ${RUBY} -I "${LIBDIR}" "${COMMAND_SCRIPT}" "${@}"
